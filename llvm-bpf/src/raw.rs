/* automatically generated by rust-bindgen */

pub const BPF_RELEASE: u32 = 199606;
pub const BPF_LD: u32 = 0;
pub const BPF_LDX: u32 = 1;
pub const BPF_ST: u32 = 2;
pub const BPF_STX: u32 = 3;
pub const BPF_ALU: u32 = 4;
pub const BPF_JMP: u32 = 5;
pub const BPF_RET: u32 = 6;
pub const BPF_MISC: u32 = 7;
pub const BPF_W: u32 = 0;
pub const BPF_H: u32 = 8;
pub const BPF_B: u32 = 16;
pub const BPF_IMM: u32 = 0;
pub const BPF_ABS: u32 = 32;
pub const BPF_IND: u32 = 64;
pub const BPF_MEM: u32 = 96;
pub const BPF_LEN: u32 = 128;
pub const BPF_MSH: u32 = 160;
pub const BPF_ADD: u32 = 0;
pub const BPF_SUB: u32 = 16;
pub const BPF_MUL: u32 = 32;
pub const BPF_DIV: u32 = 48;
pub const BPF_OR: u32 = 64;
pub const BPF_AND: u32 = 80;
pub const BPF_LSH: u32 = 96;
pub const BPF_RSH: u32 = 112;
pub const BPF_NEG: u32 = 128;
pub const BPF_MOD: u32 = 144;
pub const BPF_XOR: u32 = 160;
pub const BPF_JA: u32 = 0;
pub const BPF_JEQ: u32 = 16;
pub const BPF_JGT: u32 = 32;
pub const BPF_JGE: u32 = 48;
pub const BPF_JSET: u32 = 64;
pub const BPF_K: u32 = 0;
pub const BPF_X: u32 = 8;
pub const BPF_A: u32 = 16;
pub const BPF_TAX: u32 = 0;
pub const BPF_TXA: u32 = 128;
pub const BPF_MEMWORDS: u32 = 16;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type bpf_int32 = ::std::os::raw::c_int;
pub type bpf_u_int32 = u_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_program {
    pub bf_len: u_int,
    pub bf_insns: *mut bpf_insn,
}
#[test]
fn bindgen_test_layout_bpf_program() {
    assert_eq!(
        ::std::mem::size_of::<bpf_program>(),
        16usize,
        concat!("Size of: ", stringify!(bpf_program))
    );
    assert_eq!(
        ::std::mem::align_of::<bpf_program>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_program))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_program>())).bf_len as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(bpf_program), "::", stringify!(bf_len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_program>())).bf_insns as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(bpf_program), "::", stringify!(bf_insns))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_insn {
    pub code: u_short,
    pub jt: u_char,
    pub jf: u_char,
    pub k: bpf_u_int32,
}
#[test]
fn bindgen_test_layout_bpf_insn() {
    assert_eq!(
        ::std::mem::size_of::<bpf_insn>(),
        8usize,
        concat!("Size of: ", stringify!(bpf_insn))
    );
    assert_eq!(
        ::std::mem::align_of::<bpf_insn>(),
        4usize,
        concat!("Alignment of ", stringify!(bpf_insn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_insn>())).code as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(bpf_insn), "::", stringify!(code))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_insn>())).jt as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(bpf_insn), "::", stringify!(jt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_insn>())).jf as *const _ as usize },
        3usize,
        concat!("Offset of field: ", stringify!(bpf_insn), "::", stringify!(jf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_insn>())).k as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(bpf_insn), "::", stringify!(k))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_aux_data {
    pub vlan_tag_present: u_short,
    pub vlan_tag: u_short,
}
#[test]
fn bindgen_test_layout_bpf_aux_data() {
    assert_eq!(
        ::std::mem::size_of::<bpf_aux_data>(),
        4usize,
        concat!("Size of: ", stringify!(bpf_aux_data))
    );
    assert_eq!(
        ::std::mem::align_of::<bpf_aux_data>(),
        2usize,
        concat!("Alignment of ", stringify!(bpf_aux_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_aux_data>())).vlan_tag_present as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_aux_data),
            "::",
            stringify!(vlan_tag_present)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_aux_data>())).vlan_tag as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_aux_data),
            "::",
            stringify!(vlan_tag)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_bpf_validate"]
    pub fn bpf_validate(arg1: *const bpf_insn, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bpf_filter"]
    pub fn bpf_filter(arg1: *const bpf_insn, arg2: *const u_char, arg3: u_int, arg4: u_int) -> u_int;
}
extern "C" {
    #[link_name = "\u{1}_bpf_filter_with_aux_data"]
    pub fn bpf_filter_with_aux_data(
        arg1: *const bpf_insn,
        arg2: *const u_char,
        arg3: u_int,
        arg4: u_int,
        arg5: *const bpf_aux_data,
    ) -> u_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcap {
    _unused: [u8; 0],
}
pub type pcap_t = pcap;
extern "C" {
    #[link_name = "\u{1}_pcap_compile"]
    pub fn pcap_compile(
        arg1: *mut pcap_t,
        arg2: *mut bpf_program,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
        arg5: bpf_u_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bpf_image"]
    pub fn bpf_image(arg1: *const bpf_insn, arg2: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_bpf_dump"]
    pub fn bpf_dump(arg1: *const bpf_program, arg2: ::std::os::raw::c_int);
}
